import type { BklarInstance } from "bklar";
import type {
  OpenAPIObject,
  OperationObject,
  ParameterObject,
  ReferenceObject,
  SchemaObject,
} from "openapi3-ts/oas31";
import { z } from "zod/v4";

const toJSONSchemaOptions = {
  unrepresentable: "any" as const,
  override: (ctx: any) => {
    if (ctx.zodSchema instanceof z.ZodDate) {
      ctx.jsonSchema.type = "string";
      ctx.jsonSchema.format = "date-time";
    }
  },
};

/**
 * Creates a safe, unique name for a schema component.
 */
function createSchemaName(
  path: string,
  method: string,
  suffix: string
): string {
  const cleanPath = path
    .replace(/\/+/g, "_") // Replace slashes with underscores
    .replace(/[{}]/g, "") // Remove braces from params
    .replace(/^_/, "") // Remove leading underscore
    .replace(/_$/, ""); // Remove trailing underscore

  return `${method.toUpperCase()}_${cleanPath}_${suffix}`;
}

/**
 * Extracts and formats parameters (Path/Query) from route schemas.
 */
function processParameters(
  schemas: any
): (ParameterObject | ReferenceObject)[] {
  const parameters: (ParameterObject | ReferenceObject)[] = [];

  // Path Params
  if (schemas?.params) {
    const jsonSchema = z.toJSONSchema(schemas.params, toJSONSchemaOptions);
    if (jsonSchema.type === "object" && jsonSchema.properties) {
      for (const [key, prop] of Object.entries(jsonSchema.properties)) {
        parameters.push({
          name: key,
          in: "path",
          required: true, // Path params are always required
          schema: prop as SchemaObject,
        });
      }
    }
  }

  // Query Params
  if (schemas?.query) {
    const jsonSchema = z.toJSONSchema(schemas.query, toJSONSchemaOptions);
    if (jsonSchema.type === "object" && jsonSchema.properties) {
      for (const [key, prop] of Object.entries(jsonSchema.properties)) {
        parameters.push({
          name: key,
          in: "query",
          required: jsonSchema.required?.includes(key) || false,
          schema: prop as SchemaObject,
        });
      }
    }
  }

  return parameters;
}

export function generateOpenAPI(
  app: BklarInstance,
  config: any
): OpenAPIObject {
  const openApi: OpenAPIObject = {
    openapi: "3.1.0",
    info: {
      title: config.title || "bklar API",
      version: config.version || "1.0.0",
      description:
        config.description || "API documentation generated by @bklarjs/swagger",
    },
    paths: {},
    components: {
      ...config.components,
      schemas: config.components?.schemas || {},
    },
    security: config.security,
  };

  const components = openApi.components!; // Guaranteed to exist above

  for (const route of app.routes) {
    // Convert /users/:id to /users/{id}
    const path =
      "/" +
      route.segments
        .map((s) => (s.startsWith(":") ? `{${s.slice(1)}}` : s))
        .join("/");

    if (!openApi.paths![path]) {
      openApi.paths![path] = {};
    }

    const method = route.method.toLowerCase();
    const doc = route.options.doc || {};

    const operation: OperationObject = {
      summary: doc.summary,
      description: doc.description,
      tags: doc.tags,
      security: doc.security,
      parameters: processParameters(route.options.schemas),
      responses: {}, // Filled below
    };

    // --- Process Request Body ---
    if (route.options.schemas?.body) {
      const schemaName = createSchemaName(path, method, "Body");
      const jsonSchema = z.toJSONSchema(
        route.options.schemas.body,
        toJSONSchemaOptions
      ) as SchemaObject;

      // Register Component
      components.schemas![schemaName] = jsonSchema;

      operation.requestBody = {
        required: true,
        content: {
          "application/json": {
            schema: { $ref: `#/components/schemas/${schemaName}` },
          },
        },
      };
    }

    // --- Process Responses ---
    const routeResponses = doc.responses || {};
    const processedResponses: Record<string, any> = {};

    for (const [code, resObj] of Object.entries(routeResponses)) {
      const content = (resObj as any).content?.["application/json"];
      const schema = content?.schema;

      // Check if schema is a Zod object/type
      if (schema && typeof schema === "object" && "_def" in schema) {
        const schemaName = createSchemaName(path, method, `Res${code}`);
        const jsonSchema = z.toJSONSchema(
          schema,
          toJSONSchemaOptions
        ) as SchemaObject;

        // Register Component
        components.schemas![schemaName] = jsonSchema;

        processedResponses[code] = {
          ...(resObj as any),
          content: {
            "application/json": {
              schema: { $ref: `#/components/schemas/${schemaName}` },
            },
          },
        };
      } else {
        // Standard OpenAPI definition
        processedResponses[code] = resObj;
      }
    }

    // Default 200 OK if no responses defined
    operation.responses =
      Object.keys(processedResponses).length > 0
        ? processedResponses
        : { "200": { description: "Successful response" } };

    (openApi.paths![path] as any)[method] = operation;
  }

  return openApi;
}
